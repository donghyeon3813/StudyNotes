# 애그리거트

## 애그리거트
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들기 위해 상위 수준에서 모델을 조망할 수 있는 방법
- 관련된 객체를 하나의 군으로 묶어 준다.
- 수 많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 `일관성`을 관리하는 기준도 된다.
  - 모델을 보다 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다.
  - 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력도 줄어든다.
- 애그리거트는 `경계`를 갖는다.
  - 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
  - 경계를 설정할 때 기본이 되는 것은 `도메인 규칙`과 `요구사항`이다.
- `A가 B를 갖는다.` -> 이게 꼭 한 애그리거트에 속한다는 의미는 아님.
  - ex) 상품과 리뷰
  - 함께 생성되거나 변경되지 않고 변경 주체도 다르다.
- 도메인 규칙을 제대로 이해할수록 애그리거트의 실제 크기는 줄어든다.
  - 책에서는 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많았으며, 두 개 이상의 엔티티로 구성되는 애그리거트는 드물었다고 한다...

## 애그리거트 루트
- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 되고, 애그리거트에 속한 모든 객체가 정상 상태를 가져야만 도메인 규칙을 지킬 수 있다.
  - 관리 주체가 필요한데, 이 책임을 지는 것이 바로 `애그리거트의 루트 엔티티`

### 도메인 규칙과 일관성
- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것
  - 이를 위해 애그리거트가 제공해야 할 도메인 기능을 구현한다.
    - 이러면 너무 한 곳에 몰리지 않나...??
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안됨.
  - 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 됨.
  - 업무 규칙을 무시하고 (논리적인 데이터 일관성이 깨짐)
  - 혹은 동일한 검사 로직을 여러 응용 서비스에서 중복으로 구현할 가능성이 높아져 유지 보수에 도움이 되지 않는다.

#### - 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음의 두 가지를 습관적으로 적용해야 함.
  - 단순히 필드를 변경하는 set 메서드를 public으로 X
    - set은 도메인의 의미나 의도를 표현 못함.
    - 도메인 로직을 다른 영역으로 분산시킴
    - 도메인 로직이 한 곳에 응집되지 않으므로 유지보수나 가독성이 안좋음..
  - 밸류 타입은 불변으로 구현.
    - 애그리거트 외부에서 밸류 객체의 상태를 변경할 수 없다.
      - 애그리거트의 일관성이 깨질 가능성이 줄어듬
    - 불변을 할 수 없다면 protected...

### 애그리거트 루트의 기능 구현
- 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아님.
- 기능 실행을 위임하기도 함.
  - ex) 밸류 타입에서의 총합 계산

### 트랜잭션 범위
- 트랜잭션 범위는 작을수록 좋다.
  - 성능 차이 발생.
  - 잠금 대상이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다.(전체적인 성능(처리량)을 떨어뜨린다.)
  - 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
    - 두 개 이상의 애그리거트 수정 시, 트랜잭션 충돌 발생 가능성이 높아짐.
    - 한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.
    - 결합도가 높아짐..
- 만약 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 수정하지 말고 `응용 서비스`에서 두 애그리거트를 수정하도록 구현한다.
  - 혹은 도메인 이벤트를 사용.. -> 10장에서 ~
- 두 개 이상의 애그리거트를 변경하는 것을 고려할 상황
> - 팀 표준
> - 기술제약
> - UI 구현의 편리


## 리포지터리와 애그리거트
- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현
  - 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
  - 기본적으로 두 메서드를 기본으로 제공
    - save
    - findById
- 어떤 기술을 이용해서 리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향을 받는다.
  - JPA -> 객체 도메인 모델을 맞춰야 할 때도 있다.
  - 레거시 DB를 사용하거나 팀 내 DB 설계 표준을 따라야 한다면 DB 테이블 구조에 맞게 모델을 변경해야 함.
    - 이 경우 밸류 타입인 도메인 모델을 @Component가 아닌 @Entity를 이용해야 할 수도 있다.
- 애그치거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 함.

## ID를 이용한 애그리거트 참조
- 한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다.
- 애그리거트 관리 주체는 애그리거트 루트인데,,, 다른 애그리거트를 참조한다는 것은 다른 애그리거트 루트를 참조한다는 것과 같음.
- 이는 문제를 야기할 수 있음
  - 편한 탐색 오용
    <pre><code>orderer.getMember().changeAddress(newShippingInfo.getAddress());</code></pre>
    - 다른 애그리거트의 상태를 쉽게 변경 가능.
    - 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.
  - 성능에 대한 고민
    - 로딩 전략을 결정해야 함(지연로딩 / 즉시로딩)
  - 확장 어려움
    - 시스템을 분리할 경우, 하위 도메인마다 서로 다른 DBMS를 사용할 수도 있는데,, 결합도가 높아진다?
> ID 를 이용해서 다른 애그리거트를 참조하면 이런 문제를 완화 가능

- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고, 한 애그리거트에 속한 객체들만 참조로 연결된다.
- 이는 애그리거트의 경계를 명확히 하고, 애그리거트간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다.
- 또한 애그리거트 간의 의존을 제거하므로 응집도를 높여주는 효과도 있다.
- 구현 복잡도도 낮아진다.
  - 지연 로딩 즉시로딩 고민 X
  - 필요하면 응용 서비스에서 ID를 이용해서 로딩하면 됨

### ID를 이요한 참조와 조회 성능
- 여러 애그리거트를 읽을 때 조회 속도가 문제될 수 있음. (N + 1 과 같은..)
  - 조회 전용 쿼리를 사용하여 한 번의 쿼리로 필요한 데이터를 로딩!
  - 조회 전용 저장소를 따로 구성하면
    - 코드가 복잡해지지만
    - 시스템의 처리량을 높일 수 있다.
- 캐시나 조회 전용 저장소는 필수로 선택해야 하는 기법이다.

## 애그리거트 간 집합 연관
- 1:N 관계
<pre>
<code>
public class Product {
  ...
  private CategoryId categoryId;
  ...
}
</code>
</pre>

- M:N 연관
  - 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다.
<pre>
<code>
public class Product {
  ...
  private Set<CategoryId> categoryIds;
  ...
}
</code>
</pre>

- JPA
<pre>
<code>
@Entity
@Table(name = "product")
public class Product {
  @EmbeddedId
  private ProductId id;
  
  @ElementCollection
  @CollectionTable(name = "product_category",
      joinColumns = @JoinColumn(name = "product_id"))
  private Set<CategoryId> categoryIds;
}
</code>
</pre>

## 애그리거트를 팩토리로 사용하기
- 고객이 특정 상점을 여러 차례 신고해서 해당 상점이 더 이상 물건을 등록하지 못하도록 차단한 상태 가정.
<pre>
<code>
메소드() {
  Store store = storeRepository.findById(id);
  if (store.isBlocked()) {
    throw new ~
  }
  등록();~~
}
</code>
</pre>

->
<pre>
<code>
public class Store {
  public Product createProduct(ProductId newProductId, ...) {
    if (isBlocked()) throw new ~;
    return new Product(newProductId, getId(), ...);
  }
}
</code>
</pre>

- Store 애그리거트의 createProduct()는 Product 애그리거트를 생성하는 팩토리 역할을 한다.
- 앞선 코드와 차이점
  - 응용 서비스에서 더 이상 Store의 상태를 확인하지 않음
  - 도메인 로직은 Store에서 구현
    - 이제 Product 생성 가능 여부를 확인하는 도메인 로직을 변경해도 도메인 영역의 Store만 변경하면 됨
    - 응용 서비스는 영향 X
    - 도메인의 응집도도 높아짐
- 이거시 애그리거트를 팩토리로 사용할 때 얻을 수 있는 장점
- 조건이 추가되면?
  - 다른 팩토리에 위임
    <pre>
    <code>
      public Product createProduct(ProductId newProductId, ProductInfo pi) {
        if (isBlocked()) throw new ~;
        return ProductFactory.create(newProductId, getId(), pi);
      }
    </code>
    </pre>
    - 위임하더라도 차단 상태의 상점은 상품을 만들 수 없다는 도메인 로직은 한 곳에 계속 위치함.