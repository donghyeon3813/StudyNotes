# 3. 애그리거트 (Aggregate)

## 3.1 애그리거트의 개념

도메인 객체 모델이 복잡해지면 개별 구성 요소만 보고 전체 모델을 이해하려는 문제가 생긴다. 이로 인해 도메인 간 관계 파악이 어려워진다.  
애그리거트는 관련 객체를 군체(Group)로 묶어 도메인 모델을 더 명확하게 표현할 수 있도록 한다.

- 애그리거트에 속한 객체들은 유사하거나 동일한 라이프사이클을 가진다.

### 예시
- **주문 애그리거트**  
  주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 함께 생성된다.

### 반례
- **프로덕트(Product)**와 **리뷰(Review)**  
  서로 다른 시점에 생성되며, 주체도 다르기 때문에 별개의 애그리거트로 관리한다.

---

## 3.2 애그리거트 루트 (Aggregate Root)

애그리거트 내부 객체들이 일관된 상태를 유지하려면 이를 책임지는 주체가 필요하다.  
→ 이를 **애그리거트 루트**라고 한다.

### 3.2.1 역할
- 일관성이 깨지지 않도록 **도메인 메서드를 제공**한다.

### 3.2.2 기능 구현
- 내부 객체들의 기능을 조합하여 **루트 객체가 기능을 구현**한다.

### 3.2.3 트랜잭션의 범위
- 하나의 트랜잭션에서는 **오직 하나의 애그리거트만 수정**해야 한다.
  - 여러 애그리거트를 수정하면 루트가 아닌 객체까지 상태를 관리하게 되어 **결합도가 높아짐**.
  - 꼭 필요한 경우에는 **응용 서비스에서** 여러 애그리거트를 조합해 수정하도록 구현한다.

---

## 3.3 리포지터리와 애그리거트

- 애그리거트는 **완전한 도메인 모델 단위**로 취급되므로, **애그리거트 단위로 리포지터리가 존재**한다.
- 리포지터리는 일관성이 깨지지 않도록 **애그리거트의 모든 구성 요소를 포함**해야 한다.

---

## 3.4 ID를 이용한 애그리거트 참조

### 직접 참조의 문제점
- 한 애그리거트에서 다른 애그리거트의 상태를 **직접 변경**할 수 있어 결합도가 높아진다.
- **성능 문제** (N+1 문제 등)가 발생할 수 있다.
- **확장성 저하**: 도메인마다 다른 DB를 사용할 경우 불편해진다.

### 해결 방법
- **직접 객체 참조 대신, ID 참조**를 사용한다. (외래 키 방식 유사)

#### 3.4.1 ID 참조 시 조회 성능 문제
- ID 참조를 사용하면 조회 시 **N+1 문제**가 발생할 수 있음.
- 단순한 해결 방법: 객체 참조로 다시 변경 (하지만 이는 다시 원래 문제로 돌아감)
- 더 나은 방법: **DAO를 통해 필요한 데이터를 한 번에 조회**하는 쿼리를 작성하여 해결

---

## 3.5 애그리거트 간 집합 연관

- M:N 관계는 `@ElementCollection`을 활용하여 구현할 수 있다.

---

## 3.6 애그리거트를 팩토리로 사용하기

- 해당 내용은 다소 복잡하고 이해가 어려울 수 있음.  
  → 도메인 객체 생성 시, **복잡한 생성 과정을 캡슐화**하여 애그리거트 루트가 팩토리 역할을 맡도록 구현할 수 있다.

예: 내부 엔티티가 여러 개 생성되어야 할 경우, 루트가 해당 로직을 모두 캡슐화하고 생성 책임을 진다.
