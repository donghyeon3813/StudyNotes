# CQRS
## 단일 모델의 단점
- 주문 내역 조회 기능을 구현하려면 여러 애그리거트에서 데이터를 가져와야 함.
  - 최적화 기능 사용할 수 없음. (즉시 로딩 등)
  - JPA 네이티브 쿼리를 사용해야 할 수 있음.
- 이런 고민이 발생하는 이유는 시스템 상태를 변경할 때와 조회할 때 단일 도메인 모델을 사용하기 때문.
- 객체 지향으로 도메인 모델을 구현할 때 주로 사용하는 ORM 기법은 도메인 상태 변경 기능을 구현하는 데는 적합하지만 여러 애그리거트에서 데이터를 가져와 출력하는 기능을 구현하기에는 고려할 게 많아서 구현을 복잡하게 만드는 원인이 된다.

> 이런 구현 복잡도를 낮추기 위해 상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것.


## CQRS
- 상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 때문에 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다.
- 이를 해결하기 위한 거시 바로 CQRS (Command Query Responsibility Segregation)
  - 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회를 위한 모델을 분리하는 패턴
  - 명령 모델은 객체 지향에 기반해서 도메인 모델을 구현하기에 적당한 JPA를 사용해서 구현하고,
  - 조회 모델은 DB 테이블에서 SQL로 데이터를 조회할 때 좋은 마이바티스 등을 사용해서 구현하면 된다.
  - `조회 모델은 단순히 화면에 보여주기 위한 데이터를 보여줄 때만 사용하는건가?? 다른 애그리거트에서 조회를 할 때는 도메인으로 가져오면 되나..?`
- 조회 모델을 조회할 때는 컨트롤러에서 바로 조회 모델을 참조해도 됨.
  - 물론 로직이 필요하다면 추가해야 하지만,
  - 앞에서 나온 @Subselect 이것도 조회 모델에 포함
- 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 수도 있음. 
  - 명령 : RDBMS
  - 조회 : NoSQL
  - 동기화는 이벤트로 구현
    - 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있음
      - 실시간성 필요
        - 동기 이벤트와 글로벌 트랜잭션을 사용해서 실시간으로 동기화
          - 성능이 떨어짐
      - 여유가 있다
        - 비동기로 데이터를 전송

### 웹과 CQRS
- 일반적으로 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 많다.
- 조회 성능을 높이기 위해, 다양한 기법을 사용
  - 결국 이런 기법들은 CQRS를 적용하는 것과 같은 효과

### CQRS 장단점
#### 장점
- 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다.
  - 조회 성능을 위한 코드가 명령 모델에 없으므로, 도메인 로직을 구현하는 데 집중할 수 있다.
  - 또한, 조회 관련 로직이 사라져 복잡도가 낮아짐
- 조회 성능을 향상시키는 데 유리
  - 조회 단위로 캐시 기술을 적용할 수 있고,
  - 조회에 특화된 쿼리를 마음대로 사용할 수 있다.
  - 캐시뿐만 아니라 조회 전용 저장소를 사용하면 조회 처리량을 대폭 늘릴 수 있다.
  - 이런 코드들이 명령 모델에 영향을 주지 않음.

#### 단점
- 구현해야 할 코드가 더 많다.
  - 대규모 트래픽이 발생하는 서비스라면 조회 전용 모델을 만드는 것이 향후 유지 보수에 유리
  - 반면, 도메인이 단순하거나 트래픽이 많지 않은 서비스라면 고려해볼 필요 있
- 더 많은 구현 기술이 필요
  - 다른 구현 기술을 사용해 구현하기도 하고,
  - 경우에 따라 다른 저장소를 사용
    - 데이터 동기화를 위한 이벤트(메시징 시스템) 필요.

> 이러한 장단점을 고려해서 CQRS 패턴을 도입할 지 여부를 결정해야 함.
