# 도메인 주도 개발 시작하기 - 4장 정리

## 4.1 JPA를 이용한 리포지터리 구현
- 인프라스트럭처 계층에 JPA 구현체를 두고, 해당 구현체가 따르는 인터페이스는 도메인 패키지에 위치시킨다.
- 즉, 도메인 계층은 JPA에 대한 구체적인 의존 없이 리포지터리 인터페이스만 의존하게 된다.

## 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현
- 스프링 데이터 JPA가 제공하는 인터페이스 (`JpaRepository`, `CrudRepository` 등)를 상속받아 리포지터리를 구현할 수 있다.
- 이를 통해 반복적인 JPA 코드 없이도 기본적인 CRUD 기능을 제공받을 수 있다.

## 4.3 매핑 구현
- **루트 엔티티**는 `@Entity`로 매핑한다.
- 엔티티 내부에 포함된 **Value Object (예: Orderer)** 는 `@Embeddable`로 매핑한다.
- `@Entity` 또는 `@Embeddable`을 사용할 경우, **기본 생성자**(no-arg constructor)가 반드시 필요하다.
- JPA는 접근 방식을 `@Access` 어노테이션으로 지정할 수 있다. (`FIELD` vs `PROPERTY`)
  - 명시하지 않으면, `@Id`의 위치에 따라 접근 방식이 결정된다.
- `AttributeConverter`를 사용하여 데이터베이스에 적합한 데이터 형식으로 변환하여 저장할 수 있다.
- **Value 컬렉션 매핑**:
  - 별도 테이블에 저장할 경우: `@ElementCollection`과 `@CollectionTable`을 사용.
  - 한 컬럼에 직렬화하여 저장할 경우: `AttributeConverter` 구현 필요.
- **ID를 Value로 매핑**: `@EmbeddedId` 사용.
- 대부분의 구성 요소는 Value이며, 별도의 엔티티가 필요할 경우 그것이 진정한 엔티티인지 검토해야 한다.
- 별도 테이블로 Value를 매핑할 경우 `@SecondaryTable`과 `@AttributeOverride`를 사용한다.
- Value를 엔티티처럼 매핑하더라도, **별도의 상태 변경 메서드**는 제공하지 않는다.
- M:N 관계에서 `@ElementCollection`을 이용하는 경우, 데이터 삭제 시 **조인 테이블의 데이터도 함께 삭제**된다.

## 4.4 애그리거트 로딩 전략
- 애그리거트 루트를 로딩할 때, **루트에 속한 객체들은 완전한 상태**여야 한다.
- 그러나 모든 하위 객체가 즉시 로딩되어야 하는 것은 아니다.
- 애그리거트가 완전해야 하는 이유:
  1. 상태 변경 기능 실행 시 필요한 객체가 모두 로딩되어 있어야 함.
  2. 표현 계층에서 상태 정보를 정확히 보여주기 위해 필요.
- 표현을 위한 조회는 별도의 조회 모델 또는 전용 리포지터리를 사용하는 것이 좋다.
- JPA의 **지연 로딩(Lazy Loading)** 기능을 적절히 활용하여 실제 필요한 시점에만 로딩할 수 있다.
- 중요한 것은 **애그리거트의 목적과 사용처에 맞는 로딩 전략**을 선택하는 것.

## 4.5 애그리거트의 영속성 전파
- `@Embeddable` 타입은 소유 엔티티와 **함께 영속성 전파**된다.
- `@Entity` 타입은 `CascadeType` 설정을 통해 **수동으로 영속성 전파 설정**이 필요하다.

## 4.6 식별자 생성 기능
- 식별자(ID) 생성 전략은 요구사항에 따라 다양하게 구현 가능하다.
  - 예: JPA의 `@GeneratedValue`, UUID, 도메인 기반 생성, 리포지터리를 통한 커스텀 생성 등.

## 4.7 도메인 구현과 DIP
- 이상적으로는 `JpaRepository`와 `Entity`를 **인프라스트럭처 계층에 위치**시켜야 한다.
- 그러나 **테스트 용이성**과 **구현의 간편함**을 위해 도메인 패키지에 함께 두는 것도 합리적인 선택일 수 있다.
- 도메인 로직이 인프라 기술에 과도하게 의존하지 않는 한, 이러한 구성은 현실적인 타협점이 될 수 있다.
